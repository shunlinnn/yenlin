**流程圖
![](https://github.com/yen880405/yenlin/blob/master/image/S__2064796.jpg)

最原始花了半個禮拜看完影片釐清邏輯之後，想說分成左右兩塊
![](https://github.com/yen880405/yenlin/blob/master/image/%E8%9E%A2%E5%B9%95%E5%BF%AB%E7%85%A7%202019-11-06%20%E4%B8%8B%E5%8D%884.26.00.png)
但不知道為什麽就是跑不出來
最後決定用成現在這種切割形式


邏輯釐清看了許多影片，大概畫了邏輯圖。總之就是，把一個數列拆拆拆拆分成兩個兩個一組，最後再慢慢比大小結合比大小結合直到結束。


```python
def k(arr):
    step=2
    a=[arr[i:i+step] for i in range(0,len(arr),step)]
    return a
```

這一串初學者的我大概卡了1小時，上網利用關鍵字找到這個切成兩個兩個一塊的方式


```python
arr=[3,1,12,14,26,22,33,34,50,52]
```


```python
print (k(arr))
```

    [[3, 1], [12, 14], [26, 22], [33, 34], [50, 52]]



```python
aa=k(arr)
```

原本直接用len(k(arr))後來發現這樣是不可行的，需要套入一個新變數名稱


```python
n=len(aa)
for i in range (0,n-1):
    h=len(aa[i])
    for j in range (0,h-1):
        if (aa[i][j]>aa[i][j+1]):
            m=aa[i][j+1]
            aa[i][j+1]=aa[i][j]
            aa[i][j]=m
```

想要讓他們倆倆先比大小再結合再比大小，但光這個for迴圈上網重複查詢，嘗試了又錯又嘗試又錯又嘗試又錯又嘗試又錯又嘗試又錯又嘗試又錯又嘗試又錯又嘗試又錯又嘗試又錯又嘗試又錯又嘗試又錯又嘗試又錯大概輸出200遍大概3小時，總算邏輯稍微成功，跑出來下列結果。

最終這個回圈還包含巢狀數列的運行，兩層都跑回圈值，才能夠讓他從列表中的列表比較兩個值，才算是完成我這階段的任務


```python
print(aa)
```

    [[1, 3], [12, 14], [22, 26], [33, 34], [50, 52]]



```python
y=len(aa)
w=[r for r in aa [0:y//2]]
z=[e for e in aa[y//2:y]]
```


```python
ii=[]
for uu in w:
    if isinstance(uu,list):
        for rr in uu:
            ii.append(rr) 
```


```python
ii
```




    [1, 3, 12, 14]




```python
kk=[]
for u in z:
    if isinstance(u,list):
        for r in u:
            kk.append(r)
```


```python
kk
```




    [22, 26, 33, 34, 50, 52]


這裡因為是巢狀數列，也就是是列中包數列，要將它拆開成為一個數列耗費我大半功夫，某天半夜用到四點還想不出來，隔天早上找到這個用法函式之後，卻又一直跑出一個錯誤如下圖
![](https://github.com/yen880405/yenlin/blob/master/image/%E8%9E%A2%E5%B9%95%E5%BF%AB%E7%85%A7%202019-11-07%20%E4%B8%8B%E5%8D%882.35.37.png)
越想越奇怪怎麼搞都沒有用，決定去問助教發生什麼事，後來等待著叫回應時，各種方法都試過一遍，
邊重新編譯突然想到，我有一次的變數也設list導致有重複值造成，這個烏龍卡了超久，越想越氣。

```python
def mergeList(ii, kk):

   
     if len(ii) == 0: 
         return kk
     elif len(kk) == 0: 
         return ii
   
     elif ii[0] < kk[0]:
         return [ii[0]] + mergeList(ii[1:], kk)
     
     else: 
         return [kk[0]] + mergeList(ii, kk[1:])
```


```python
print( mergeList(ii, kk))
```

    [1, 3, 12, 14, 22, 26, 33, 34, 50, 52]


很開心想出來之後，覺得真的太有成就感，太開心，花了我將近兩個禮拜的時間，過了一會兒，越想越不對勁，發現我這樣鐵定有一個bug，就是我巢狀列表第二層可以比較順序，但合成兩個數列時，並沒有互相比較大小，這樣子的話，當我的ii數列有一個超大值擋住後面較小的值，將永遠無法跑進去，後面就會開始亂掉，但今天已經是星期四的晚上了，我改成助教要的格式大概還要花大半輩子，先自首我這邊有bug，如果晚點用完還有時間再來思考，不然也只能等交作業後再重新構思了。

![](https://github.com/yen880405/yenlin/blob/master/image/%E8%9E%A2%E5%B9%95%E5%BF%AB%E7%85%A7%202019-11-07%20%E4%B8%8B%E5%8D%884.50.09.png)
完蛋，我根本沒學過助教的class概念，我前面程式碼雖然是開放式程式碼，不是閉鎖式的程式碼，但需要一步驟一步驟呈現執行，完全對class沒有概念的我，覺得這兩個禮拜的努力堅持純手工完全白費。

最後我問了幾位朋友發現似乎還有救，就上網尋找解決方式，並同時求助朋友

修美變數名稱跟一些邏輯語法還有學會如何class之後，突然覺得雖然我的程式碼並沒有達成老師所要求的版本，但靠自己一步一腳印完全自創，也是有一番新滋味，何時起步都不算晚，儘管程式碼不完美，有努力過的過程才是重點，之後再持續增進自我程式語法邏輯能力，希望可以趕快追上腳步。
