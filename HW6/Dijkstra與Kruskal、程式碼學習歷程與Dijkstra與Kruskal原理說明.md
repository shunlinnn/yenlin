**Dijkstra與Kruskal原理說明**

* Dijkstra

戴克斯特拉算法（英語：Dijkstra's algorithm）由荷蘭電腦科學家艾茲赫爾·戴克斯特拉在1956年提出。戴克斯特拉算法使用了廣度優先搜尋解決賦權有向圖的單源最短路徑問題。該演算法存在很多變體；戴克斯特拉的原始版本找到兩個頂點之間的最短路徑，但是更常見的變體固定了一個頂點作為源節點然後找到該頂點到圖中所有其它節點的最短路徑，產生一個最短路徑樹。該演算法常用於路由演算法或者作為其他圖演算法的一個子模組。舉例來說，如果圖中的頂點表示城市，而邊上的權重表示城市間開車行經的距離，該演算法可以用來找到兩個城市之間的最短路徑。

該演算法的輸入包含了一個有權重的有向圖 G，以及G中的一個來源頂點 S。我們以 V 表示 G 中所有頂點的集合。每一個圖中的邊，都是兩個頂點所形成的有序元素對。(u, v) 表示從頂點 u 到 v 有路徑相連。我們以 E 表示G中所有邊的集合，而邊的權重則由權重函式 w: E → [0, ∞] 定義。因此，w(u, v) 就是從頂點 u 到頂點 v 的非負權重（weight）。邊的權重可以想像成兩個頂點之間的距離。任兩點間路徑的權重，就是該路徑上所有邊的權重總和。已知 V 中有頂點 s 及 t，Dijkstra 演算法可以找到 s 到 t 的最低權重路徑(例如，最短路徑)。這個演算法也可以在一個圖中，找到從一個頂點 s 到任何其他頂點的最短路徑。

最初的戴克斯特拉算法不採用最小優先級佇列，時間複雜度是{\displaystyle O(|V|^{2})}O(|V|^{2})(其中{\displaystyle |V|}|V|為圖的頂點個數)。通過斐波那契堆實現的戴克斯特拉算法時間複雜度是{\displaystyle O(|E|+|V|\log |V|)}O(|E|+|V|\log |V|) (其中{\displaystyle |E|}|E|是邊數) [2]。對於不含負權的有向圖，這是目前已知的最快的單源最短路徑演算法


這個演算法是通過為每個頂點 v 保留目前為止所找到的從s到v的最短路徑來工作的。初始時，原點 s 的路徑權重被賦為 0 （d[s] = 0）。若對於頂點 m 存在能直接到達的邊（s,m），則把d[m]設為w（s, m）,同時把所有其他（s不能直接到達的）頂點的路徑長度設為無窮大，即表示我們不知道任何通向這些頂點的路徑（對於所有頂點的集合 V 中的任意頂點 v， 若 v 不為 s 和上述 m 之一， d[v] = ∞）。當演算法結束時，d[v] 中儲存的便是從 s 到 v 的最短路徑，或者如果路徑不存在的話是無窮大。

邊的拓展是Dijkstra 演算法的基礎操作：如果存在一條從 u 到 v 的邊，那麼從 s 到 v 的最短路徑可以通過將邊（u, v）添加到從 s 到 u 的路徑尾部來拓展一條從 s 到 v 的路徑。這條路徑的長度是 d[u] + w(u, v)。如果這個值比目前已知的 d[v] 的值要小，我們可以用新值來替代當前 d[v] 中的值。拓展邊的操作一直執行到所有的 d[v] 都代表從 s 到 v 的最短路徑的長度值。此演算法的組織令 d[u] 達到其最終值時，每條邊（u, v）都只被拓展一次。

演算法維護兩個頂點集合 S 和 Q。集合 S 保留所有已知最小 d[v] 值的頂點 v ，而集合 Q 則保留其他所有頂點。集合S初始狀態為空，而後每一步都有一個頂點從 Q 移動到 S。這個被選擇的頂點是 Q 中擁有最小的 d[u] 值的頂點。當一個頂點 u 從 Q 中轉移到了 S 中，演算法對 u 的每條外接邊 (u, v) 進行拓展。

下面的虛擬碼計算並保留圖G中原點s到每一頂點v的最短距離d[v]，同時找出並保留v在此最短路徑上的「前趨」，即沿此路徑由s前往v，到達v之前所到達的頂點。其中，函式Extract_Min(Q) 將頂點集合Q中有最小d[u]值的頂點u從Q中刪除並返回u。

在日常生活中，我們如果需要常常往返A地區和B地區之間，我們最希望知道的可能是從A地區到B地區間的眾多路徑中，那一條路徑的路途最短。最短路徑問題是圖論研究中的一個經典演算法問題，旨在尋找圖（由結點和路徑組成的）中兩結點之間的最短路徑。 演算法具體的形式包括：

（１）確定起點的最短路徑問題：即已知起始結點，求最短路徑的問題。

（２）確定終點的最短路徑問題：與確定起點的問題相反，該問題是已知終結結點，求最短路徑的問題。在無向圖中該問題與確定起點的問題完全等同，在有向圖中該問題等同於把所有路徑方向反轉的確定起點的問題。

（３）確定起點終點的最短路徑問題：即已知起點和終點，求兩結點之間的最短路徑。

（４）全域性最短路徑問題：求圖中所有的最短路徑。


* Kruskal

Kruskal演算法是一種用來尋找最小生成樹的演算法，由Joseph Kruskal在1956年發表。用來解決同樣問題的還有Prim演算法和Boruvka演算法等。三種演算法都是貪婪演算法的應用。和Boruvka演算法不同的地方是，Kruskal演算法在圖中存在相同權值的邊時也有效。

最小生成樹是一副連通加權無向圖中一棵權值最小的生成樹。

在一給定的無向圖 G = (V, E) 中，(u, v) 代表連接頂點 u 與頂點 v 的邊（即 {\displaystyle (u,v)\in E}(u,v)\in E），而 w(u, v) 代表此邊的權重，若存在 T 為 E 的子集（即 {\displaystyle T\subseteq E}T\subseteq E）且 (V, T) 為樹，使得

{\displaystyle w(T)=\sum _{(u,v)\in T}w(u,v)}w(T)=\sum _{(u,v)\in T}w(u,v)
的 w(T) 最小，則此 T 為 G 的最小生成樹。

最小生成樹其實是最小權重生成樹的簡稱。

一個連通圖可能有多個生成樹。當圖中的邊具有權值時，總會有一個生成樹的邊的權值之和小於或者等於其它生成樹的邊的權值之和。廣義上而言，對於非連通無向圖來說，它的每一連通分量同樣有最小生成樹，它們的並被稱為最小生成森林。

以有線電視電纜的架設為例，若只能沿著街道布線，則以街道為邊，而路口為頂點，其中必然有一最小生成樹能使布線成本最低。



參考資料：https://zh.wikipedia.org/wiki/%E6%88%B4%E5%85%8B%E6%96%AF%E7%89%B9%E6%8B%89%E7%AE%97%E6%B3%95
        http://alrightchiu.github.io/SecondRound/minimum-spanning-treekruskals-algorithm.html
        http://alrightchiu.github.io/SecondRound/shortest-pathintrojian-jie.html
        http://alrightchiu.github.io/SecondRound/single-source-shortest-pathdijkstras-algorithm.html
